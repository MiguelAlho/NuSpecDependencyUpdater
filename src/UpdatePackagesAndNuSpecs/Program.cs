using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml;

namespace UpdatePackagesAndNuSpecs
{
    class Program
    {
        static void Main(string[] args)
        {

            /* this app is VERY opinionated. 
             * 
             * I takes two steps toward updating a package that is origonated in a different solution.
             * 
             * It will update a list of packages generated by the external solution. 
             * Once updated, all nuspec within the current solution will be updated to 
             * set the minimum version to that package's version number.
             * 
             * This will help maintain all packages up to date, cross project solutions.
             * 
           * This is more of a convention than a requirement, and will simplify dependency 
           * management by convention
           * 
           * */
            
            
            string currentDirectory = Directory.GetCurrentDirectory();  //not necessariely the exec's dir.
            string execDirectory = AppDomain.CurrentDomain.BaseDirectory;
            string packageListFileName = "packageList.toupdate";

            string solutionFile = GetSolutionFile(currentDirectory);
            if(String.IsNullOrEmpty(solutionFile))
            {
                Console.WriteLine("No solution files are present in the directory");
                return;
            }

            string packageListFilePath = Path.Combine(execDirectory, packageListFileName);
            if(!File.Exists(packageListFilePath))
            {
                Console.WriteLine("packageList.toupdate is missing. Please create the file in the same folder as this executable.");
                return;
            }

            string[] packageList = File.ReadAllLines(packageListFilePath);
            if(packageList.Length == 0)
            {
                Console.WriteLine("packageList.toupdate does not refere packages to update.");
                return;
            }


            CallNugetUpdateForEachPackage(packageList, solutionFile);
            Dictionary<string, VersionInfo> versions = LoadPackageVersionsInSolution(packageList, currentDirectory);
            UpdateSolutionNuspecsToMinimum(packageList, currentDirectory, versions);

            Console.WriteLine("Done.");
            
            
        }

        private static string GetSolutionFile(string currentDirectory)
        {
            string[] solutionFilesInDir = Directory.GetFiles(currentDirectory, "*.sln", SearchOption.TopDirectoryOnly);
            string solutionFile;
            if (solutionFilesInDir.Length == 0)
            {
                return null;
            }
            else if (solutionFilesInDir.Length > 1)
            {
                Console.WriteLine("More than one solution file found. {0} will be used.", solutionFilesInDir[0]);
            }

            return solutionFilesInDir[0];

        }

        private static void UpdateSolutionNuspecsToMinimum(string[] packageList, string currentDirectory, Dictionary<string, VersionInfo> versions)
        {
            Console.WriteLine("scanning for nuspecs");
           
            string[] nuspecs = Directory
                                    .GetFiles(currentDirectory, "*.nuspec", SearchOption.AllDirectories)
                                    .Where(o => !o.Contains(@"\obj\") && !o.Contains(@"\packages\")).ToArray();
            
            foreach(var nuspec in nuspecs)
            {
                Console.WriteLine("Updating {0}", nuspec);

                XmlDocument doc = new XmlDocument();
                doc.Load(nuspec);

                foreach(string packageId in versions.Keys)
                {
                    XmlNode node = doc.SelectSingleNode(
                            String.Format("/package/metadata/dependencies/dependency[@id=\"{0}\"]", packageId));
                    if (node != null)
                    {
                        node.Attributes["version"].Value = versions[packageId].ToGamaString();

                        Console.WriteLine("\t{0} updated to {1}", packageId, versions[packageId].ToGamaString());
                    }
                }

                doc.Save(nuspec);
            }
        


        }


        private static Dictionary<string, VersionInfo> LoadPackageVersionsInSolution(string[] packageList, string currentDirectory)
        {
            Console.WriteLine("\tScanning packages folder for versions");
            string packageFolder = Path.Combine(currentDirectory, "packages");

            Dictionary<string, VersionInfo> versions = new Dictionary<string, VersionInfo>();

            foreach (string packageId in packageList)
            {
                string pattern = packageId + @".\d{1,5}.\d{1,5}(.\d{1,5})?(.\d{1,5})?";
                string[] directories = Directory.GetDirectories(packageFolder, "*", SearchOption.TopDirectoryOnly)
                                        .Where(o => Regex.Match(o, pattern, RegexOptions.IgnoreCase).Success).ToArray();
                
                if(directories == null || directories.Length == 0)
                {
                    Console.WriteLine("Error: package folder for {0} not found!", packageId);
                    return null;
                }

                List<VersionInfo> versionsFound = new List<VersionInfo>();
                foreach (string directory in directories)
                {
                    DirectoryInfo dirInfo = new DirectoryInfo(directory);
                    string name = dirInfo.Name;

                    VersionInfo version = VersionInfo.GetVersionFromPackageForlderName(name);

                    if (version == null)
                    {
                        Console.WriteLine("Error: package folder for {0} does not contain a parsable version number!", packageId);
                        return null;
                    }

                    versionsFound.Add(version);
                }


                VersionInfo maxVersion = VersionInfo.GetHighestVersionFromList(versionsFound);
                versions.Add(packageId, maxVersion);
                Console.WriteLine("\t{0} @ version {1}", packageId, maxVersion.ToString());
            }

            return versions;
        }

        private static void CallNugetUpdateForEachPackage(string[] packageList, string solutionFile)
        {
            foreach (string packageId in packageList)
            {
                Console.WriteLine("Updating {0}.....", packageId);
                
                // For the example
                string currentDirectory = Directory.GetCurrentDirectory(); 
                string nugetExePath = Path.Combine(currentDirectory, @".nuget\nuget.exe");
                string nugetConfigPath = Path.Combine(currentDirectory, @".nuget\nuget.config");
                string solutionPath = Path.Combine(currentDirectory, solutionFile);

                
                // Use ProcessStartInfo class
                ProcessStartInfo startInfo = new ProcessStartInfo();
                startInfo.CreateNoWindow = false;
                startInfo.UseShellExecute = false;
                startInfo.FileName = nugetExePath;
                startInfo.WindowStyle = ProcessWindowStyle.Hidden;
                startInfo.Arguments = string.Format("update {0} -Id {1} -Verbosity detailed -configFile {2}",
                    solutionFile,
                    packageId,
                    nugetConfigPath);

                try
                {
                    // Start the process with the info we specified.
                    // Call WaitForExit and then the using statement will close.
                    using (Process exeProcess = Process.Start(startInfo))
                    {
                        exeProcess.WaitForExit();
                    }
                }
                catch
                {
                    // Log error.
                }

                Console.WriteLine("Done updating {0}!", packageId);
            }
        }
    }

    class VersionInfo : IComparable
    {
        public int Major { get; private set; }
        public int Minor { get; private set; }
        public int Patch { get; private set; }
        public int Revision { get; private set; }

        public VersionInfo(int major, int minor = 0, int patch = 0, int revision = 0)
        {
            Major = major;
            Minor = minor;
            Patch = patch;
            Revision = revision;
        }

        public override string ToString()
        {
            return string.Format("{0}.{1}.{2}.{3}", Major, Minor, Patch, Revision);
        }

        public string ToGamaString()
        {
            return string.Format("[{0}.{1}.{2}.{3},{4}.0.0.0)", Major, Minor, Patch, Revision, Major+1);
        }

        public static VersionInfo GetVersionFromPackageForlderName(string name)
        {
            string pattern = @"\.(?<major>\d{1,5})\.(?<minor>\d{1,5})\.?(?<patch>\d{1,5})?\.?(?<revision>\d{1,5})?";

            Match match = Regex.Match(name, pattern);

            int major;
            int minor;
            int patch;
            int revision;

            int.TryParse(match.Groups["major"].Value, out major);
            int.TryParse(match.Groups["minor"].Value, out minor);
            int.TryParse(match.Groups["patch"].Value, out patch);
            int.TryParse(match.Groups["revision"].Value, out revision);

            if (match.Success)
            {
                return new VersionInfo(
                    major,
                    minor,
                    patch,
                    revision
                    );
            }

            return null;
        }



        public int CompareTo(object objToCompare)
        {
            VersionInfo obj = (VersionInfo)objToCompare;

            if(Major != obj.Major)
            {
                return Major.CompareTo(obj.Major);
            }
            else if(Minor != obj.Minor)
            {
                return Minor.CompareTo(obj.Minor);
            }
            else if(Patch != obj.Patch)
            {
                return Patch.CompareTo(obj.Patch);
            }
            else //if(Revision != obj.Revision)
            {
                return Revision.CompareTo(obj.Revision);
            }
        }

        internal static VersionInfo GetHighestVersionFromList(List<VersionInfo> versionsFound)
        {
            return versionsFound.Max();
        }
    }
}
